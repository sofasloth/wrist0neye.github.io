---
title: 유연한 프로그래밍을 위한 설계원칙 조금 살펴보기
date: 2024-08-23 02:26:00 +0900
categories:
  - Programming
  - Reference
tags:
  - Book
  - design
  - architecture
  - lisp
  - racket
  - scheme
  - python
  - deno
  - jupyter
  - Javascript
pin: false
mermaid: "false"
image: 
incomplete: true
math: true
published: true
comments: true
---
이번 글에서는 2장 영역 특화 언어(DSL) 초반부만 Python, javascript와 비교해보려고 한다. Jupyter notebook에서 커널을 각각 Python, Deno로 설정해 racket 코드를 그대로 구현해보려고 한다.

## DSL
### 조합자
함수 조합자 `compose`는 고등학교 수학에서 배운 함수의 합성과 유사하다. 조합자는 두 개 이상의 함수를 인자로 받아 합성한 함수를 리턴한다. 다음 코드를 참고하자.

$$(f \circ g)(args) = f(g(args))$$


```lisp
(define (compose f g) 
	(lambda args
		(f (apply g args) )
	)
)
```

![Pasted image 20240823011355](/assets/img/res/Pasted%20image%2020240823011355.png)

위 코드의 예제는 아래와 같다.
```lisp
((compose (lambda (x) (list 'foo x)) ;문자열 ['foo', x] 리스트 생성
			(lambda (x) (list 'bar x)) ;문자열 ['bar', x] 리스트 생성
)'z); 문자 'z' 입력
'(foo (bar z)) ; 리턴값
```


![Pasted image 20240823013831](/assets/img/res/Pasted%20image%2020240823013831.png)

#### 조합자 내부 프리시저 이름 붙이기
이번에는 `compose` 프리시저 안에 함수 합성 결과물에 이름을 붙이고 싶다고 한다. 쉽게 말해서 `lambda` 함수를 사용하지 않고 **함수 안에 함수**를 정의하려고 한다.

```lisp
(define (compose f g)
	(define (the-composition . args)
		(f (apply g args))
	)
	the-composition
)
```

![Pasted image 20240823020509](/assets/img/res/Pasted%20image%2020240823020509.png)

#### 조합자 응용 : 재귀함수
`compose` 조합자만으로도 $f^n(n) = f(f^{n-1}(x))$ 재귀함수를 구현할 수 있다. 
```lisp
(define ((iterate n) f)
	(if (= n 0)
		identity ; racket의 return 키워드
		(compose f ((iterate (- n 1)) f))
	)
)

(define sqaure (lambda x (* x x)))
(((iterate 3) square) 5) ;390625
```
- `identity`는 [racket docs](https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._identity%29%29)에 있는데 `return` 키워드랑 동일하다.
	- `racket` 문법 상 `(define (identity x) x)`으로 보면 된다.
- 책에서는 위 코드처럼 적혀 있는데 아래처럼 `(iterate n) f`대신 `(iterate n f)`처럼 적어도 된다.

```lisp
(define (iterate n f)
	(if (= n 0)
		identity ; racket의 return 키워드
		(compose f (iterate (- n 1) f))
	)
)

((iterate 3 square) 5) ;390625
```
위 함수의 매커니즘은 아래와 같다.

$$(f \circ f \circ f)(5) = f(f(f(5))) = (((5^2)^2)^2) = 5^8 = 390625$$


![](/assets/img/res/Pasted%20image%2020240823032408.png)

### 병렬 조합자
이번에는 두 가지 이상의 함수를 한 번에 합성하는 병렬 조합자를 살펴보자.
![](/assets/img/res/Pasted%20image%2020240823033100.png)

```lisp
(define (parallel-combine h f g)
	(define (the-combination . args)
		h (apply f args) (apply args)
	)
	the-combination
)

((parallel-combine list
	(lambda (x y z) (list 'foo x y z))
	(labmda (u v w) (list 'bar u v w)))
'a 'b 'c)
```

![](/assets/img/res/Pasted%20image%2020240823034106.png)

이 병렬 조합자는 복잡한 과정을 조직화할 때 사용하면 좋다고 한다. 책에서 말하기를 여러 장의 채소 사진 이미지들을 입력하면 *채소의 색상을 추정하는 프로시저* `함수 f`, *채소의 형태(잎, 뿌리, 줄기 등)를 서술하는 프로시저* `함수 g`를 *조합해서 판정하는 프로시저* `함수 h`를 만들 때 위 방식으로 사용하면 깔끔하게 만들 수 있다고 한다.

### 항수


아무튼 이와 같은 방식으로 `racket`이라는 생소한 코드를 이해하려고 하면 책의 저자가 말하고자 하는 프로그래밍 스타일에 대해서 이해하는데 도움은 될 것이다. 영어 공부할 때 일일이 번역하는 것처럼 비효율적일 수는 있겠지만, 처음보면서 꽤 유익한 프로그래밍 스타일이 많아 앞으로 차근차근 공부할 예정이다. <span id="Fine">■</span>

## Reference
{% linkpreview "https://product.kyobobook.co.kr/detail/S000001810497" %}